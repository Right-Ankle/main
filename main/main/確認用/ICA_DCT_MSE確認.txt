#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include <stdlib.h>
#include <math.h>
#include "ica.h"

int main()
{
	FILE* fp, * fp2; //ファイルポインタの定義

	//宣言
	static unsigned char origin[256][256] = { 0 };	//原画像（256*256のみ対応）
	//static  double ori_temp2[64][1024] = { 0 };
	static int i, j, n, m, k, l, mk, ml, Q, QQ, b, a, ori_temp[256 * 256];
	static double sum, min, mse_dct[64][1024], mse_ica[64][1024], result_dct[2][1024], result_ica[2][1024], result[2][1024];
	static double coe[256][256] = { 0 }, dct_coe[64][1024] = { 0 }, coe_temp[256][256] = { 0 }, dcoe[256][256] = { 0 };
	static double avg[1024], y[64][1024], w[64][64], ny[64][1024], nw[64][64], x[64][1024], xx[64], dcoe_temp2[64][1024], dcoe_temp[64][1024] = { 0 };
	static unsigned char dammy[256][256] = { 0 };
	static unsigned char block_dct[64], dcoe2[256][256] = { 0 }, block_ica[64];
	static unsigned char  ica_sai[256][256] = { 0 };
	static struct pca pcaStr = { 0 };
	static char image_name[20] = { 0 };	//画像ファイル名(拡張子含まず)
	char output[20];
	struct tt** sort_d, temp;

	sum = 0;

	//読み込むファイル名
	static char filename[20] = { 'b', 'a', 'r', 'b', 'a', 'r', 'a', '.', 'b', 'm', 'p' };

	if (img_read_gray(ori_temp, filename, image_name, 256, 256) != 0)
		return -1;

	/* 一次元配列から二次元配列に変換 */
	for (i = 0; i < 256; i++)
		for (j = 0; j < 256; j++)
			origin[i][j] = ori_temp[i * 256 + j];


	//ソート用
	sort_d = (struct tt**)malloc(sizeof(struct tt*) * 64);
	for (i = 0; i < 64; i++) {
		sort_d[i] = (struct tt*)malloc(sizeof(struct tt) * 1024);
	}

	//出力ファイル　宣言
	if ((fp = fopen("test_dct.txt", "a")) == NULL) {
		fprintf(stderr, "Can not open file\n");
	}

	if ((fp2 = fopen("test_ica.txt", "a")) == NULL) {
		fprintf(stderr, "Can not open file\n");
	}

	/////////////////宣言処理 終了///////////////////////


	// ///////////////////////// ica //////////////////////////////////
	// ICA基底・係数
	// origin = 画素値(256*256),  y = ica係数(ブロックで64個で1024ブロック分),  w = ica基底(64個の計算法の中にそれぞれ64個の計算法がある)
	// ICAに"origin"を入れることで"y"(計算後の値)と"w"(計算の仕方)の結果が出力される
	// 基底は計算方法。係数は 8*8の画素ブロックを構成するのに 64個の基底がそれぞれ どれくらい使われているのか（含まれているか）の値。
	// ブロックとは 256*256画素のうち縦8横8のブロック。一画像につき(256/8) 32*32 = 1024ブロック
	pcaStr = new_pca(origin);
	ICA(origin, pcaStr, y, w, avg, 100, 0.002);

	// 計算用にコピー
	for (i = 0; i < 1024; i++)
		for (j = 0; j < 64; j++)
			ny[j][i] = y[j][i]; // ny -> yy(ica係数コピー)

	for (i = 0; i < 64; i++)
		for (j = 0; j < 64; j++)
			nw[j][i] = w[j][i]; // nw-> w(ica基底コピー)

	// 普通の再構成処理（ICAで分解した"y"と"w"から"origin"を再構成）
	//（関係ない）
	seki5(nw, ny, x); // x -> nw * ny
	xtogen(x, ica_sai, avg); // ica_sai -> 再構成済①
	avg_inter(ica_sai, avg); // ica_sai -> 再構成済②

	// 64個の基底のうち1個だけ使用するための処理
	// 基底はいじれないから、使用する係数を64個から1個に制限する。
	// ブロック内で使用する基底を1個×64個あるから64パターン×全1024ブロック
	for (j = 0; j < 1024; j++) {
		for (i = 0; i < 64; i++) {
			b = i;

			// 該当係数以外0
			// i番目の係数（基底）のみ使用。それ以外の係数は0。
			for (a = 0; a < 64; a++) {
				if (b == a)
					ny[a][j] = y[a][j];
				else
					ny[a][j] = 0;
			}

			// 初期化（必ず行う）
			for (a = 0; a < 64; a++)
				xx[a] = 0.0;

			// 1ブロックで処理を行っているため、そのブロック番号（ｊ）の係数と
			// すべての基底を用いることで もとのブロックを再構成する処理
			seki5_Block(nw, ny, xx, j); // xx64 -> nw * ny
			xtogen_Block(xx, block_ica, avg, j); // ica_sai -> 再構成済①
			avg_inter_Block(block_ica, avg, j); // ica_sai -> 再構成済②

			// ブロックごとのMSE
			// MSEは（元の値 - 再構成の値）^2をすることで
			// 再構成した値が元の値とどれくらいずれているのかを見るための指標
			sum = 0.0;
			mk = j % 32;
			ml = j / 32;

			// 64個の2乗の平均からそのブロックが平均してどれくらい ずれているのかを見る
			// （ちなみに、1ブロックにつき64パターン＊全1024ブロック）
			for (a = 0; a < 8; a++) {
				for (b = 0; b < 8; b++) {
					sum += pow(origin[ml * 8 + b][mk * 8 + a] - block_ica[b * 8 + a], 2);
				}
			}
			mse_ica[i][j] = sum / 64;//平均
		}
		// 実行確認用
		printf("%d\n", j);
	}

	// ///////////// ica MSE ソート/////////////////////////
	for (i = 0; i < 64; i++) {
		for (j = 0; j < 1024; j++) {
			// .val -> 値を取得・属性を変更し記憶
			// .abs -> 絶対値を記憶
			// .num -> 元々の係数に対応するブロック内番号を記憶
			sort_d[i][j].val = mse_ica[i][j];		/* 元々の係数値 */
			sort_d[i][j].abs = fabs(mse_ica[i][j]);	/* ソートは係数の絶対値で行う*/
			sort_d[i][j].num = (double)i;					/* numに元々の係数に対応する番号を記憶 */
		}
	}

	for (n = 0; n < 1024; n++) {
		for (i = 0; i < 64 - 1; i++) {
			min = sort_d[i][n].abs;
			k = i;
			for (j = i + 1; j < 64; j++) {
				if (mse_ica[j][n] < min) {
					min = sort_d[j][n].abs;
					k = j;
				}
			}
			temp = sort_d[i][n];
			sort_d[i][n] = sort_d[k][n];
			sort_d[k][n] = temp;
		}
	}
	////////////////////////////ソート終了////////////////////////////////

	//ソート結果を格納
	// 各ブロック64パターンの中で一番誤差のないもの
	for (i = 0; i < 1024; i++) {
		result_ica[0][i] = sort_d[0][i].num;  // 基底番号
		result_ica[1][i] = sort_d[0][i].val;    // MSE値
	}


	// ICA確認
	fprintf(fp2, "\n<Num ICA>\n");
	for (i = 0; i < 1024; i++) {
		fprintf(fp2, "%2d, ", (int)result_ica[1][i]);
		if (i % 32 == 31) {
			fprintf(fp2, "\n");
		}
	}
	fprintf(fp2, "\n");

	//動作確認
	printf("<ica fin>\n\n");
	/////////////////////////////////ica 終了/////////////////////////////////////////


	// //////////////////////////// dct ////////////////////////////////////////
	// ICA と大体同じ。DCTの基底は汎用的だから決まっている。係数のみを動かせばいい

	//動作確認
	printf("<dct start>\n");

	// 10段階品質があるから10段階分やる
	for (Q = 100; Q > 0; Q -= 10) {
		printf("now Q is %d\n", Q);

		// dct処理
		dct(origin, dcoe, 8); // 係数を出力
		quantization(dcoe, Q); // 係数の品質を10段階で落とす処理（量子化）落とせば落とすほどデータは軽くなるが、品質が落ちる
		idct(dcoe, dcoe2, 8); // 普通の再構成

		// 256*256->64*1024（係数の順番を変更)
		//  256*256だと0番目のブロックの値は [0~7]*[0~7]に格納されている（1番目だと[0~7]*[8~15]) が、
		//  64*1024にすれば[0~64]*[0]と計算しやすく・わかりやすくなる
		dctcoe_conv(dcoe, dcoe_temp);

		for (j = 0; j < 1024; j++) {
			for (i = 0; i < 64; i++) {
				b = i;

				// 該当係数以外0
				//for (a = 0; a < 64; a++) {
				//	if (b == a)
				//		dcoe_temp2[a][j] = dcoe_temp[a][j];
				//	else
				//		dcoe_temp2[a][j] = 0;
				//}

				idct_Block(dcoe_temp2, block_dct, 8, j);  //対象blockだけの再構成

			   // ブロックごとのMSE
				sum = 0.0;
				mk = j % 32;
				ml = j / 32;

				for (a = 0; a < 8; a++) {
					for (b = 0; b < 8; b++) {
						sum += pow(origin[ml * 8 + b][mk * 8 + a] - block_dct[a * 8 + b], 2);
						fprintf(fp2, "num[%d][%d] : %d , %d\n", ml * 8 + b, mk * 8 + a, dcoe2[ml * 8 + b][mk * 8 + a], block_dct[a * 8 + b]);
					}
				}
				mse_dct[i][j] = sum / 64;
			}
			// 実行確認用
			//printf("%d\n", j);
		}

		// /////////ソート//////////////
		// dctソート
		for (i = 0; i < 64; i++) {
			for (j = 0; j < 1024; j++) {
				// .val -> 値を取得・属性を変更し記憶
				// .abs -> 絶対値を記憶
				// .num -> 元々の係数に対応するブロック内番号を記憶
				sort_d[i][j].val = mse_dct[i][j];		/* 元々の係数値 */
				sort_d[i][j].abs = fabs(mse_dct[i][j]);	/* ソートは係数の絶対値で行う*/
				sort_d[i][j].num = (double)i;					/* numに元々の係数に対応する番号を記憶 */
			}
		}

		for (n = 0; n < 1024; n++) {
			for (i = 0; i < 64 - 1; i++) {
				min = sort_d[i][n].abs;
				k = i;
				for (j = i + 1; j < 64; j++) {
					if (mse_dct[j][n] < min) {
						min = sort_d[j][n].abs;
						k = j;
					}
				}
				temp = sort_d[i][n];
				sort_d[i][n] = sort_d[k][n];
				sort_d[k][n] = temp;
			}
		}
		/////////////////////ソート終了////////////////////////

		// ソート結果を格納
		for (i = 0; i < 1024; i++) {
			result_dct[0][i] = sort_d[0][i].num;
			result_dct[1][i] = sort_d[0][i].val;
		}
		/////////////////////////dct 終了/////////////////////////////


		// mse結果の比較
		for (i = 0; i < 1024; i++) {
			if (result_dct[1][i] < result_ica[1][i]) { // dctのほうが小さければ
				result[0][i] = 0.0;
				result[1][i] = result_dct[0][i]; //基底番号を格納
			}
			else {
				result[0][i] = 1.0;   // （今のところすべてこっちになる）
				result[1][i] = result_ica[0][i];
			}
		}


		////////////////出力///////////////////
		//上位１（基底番号）
		//fprintf(fp, "\nUSE Q [%d]\n", Q);
		//fprintf(fp, "\n<Num>\n");
		//fprintf(fp2, "\nUSE Q [%d]\n", Q);
		//fprintf(fp2, "\n<Num>\n");

		for (i = 0; i < 1024; i++) {
			fprintf(fp, "%3d:  %3d ", (int)mse_dct[1][i], (int)mse_ica[1][i]);
			//if (i % 32 == 31) {
				fprintf(fp, "\n");
			//}
		}
		fprintf(fp, "\n\n");

		//上位１こ（MSE値）
		//fprintf(fp, "\n<MSE Val>\n");
		//for (i = 0; i < 1024; i++) {
		//	fprintf(fp, "%5d, ", (int)sort_d[0][i].val);
		//	if (i % 32 == 31)
		//		fprintf(fp, "\n");
		//}

		//////////////////出力終了///////////////////////
	} // dctの最初に戻る

	fclose(fp);
	fclose(fp2);

	for (i = 0; i < 64; i++) {
		free(sort_d[i]);
	}
	free(sort_d);
	printf("finish");

}